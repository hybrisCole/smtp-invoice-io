fn imap_io() {
    let now = Instant::now();
    let conn = Connection::connect("postgresql://cole28:cole28@localhost:5432/factura28", TlsMode::None)
        .unwrap();
    let tls = native_tls::TlsConnector::builder().build().unwrap();
    let client = imap::connect((DOMAIN, 993), DOMAIN, &tls).unwrap();
    let stmt_create_factura =
        conn.prepare_cached("CALL create_factura($1, $2, $3, $4, $5, $6)").unwrap();
    let stmt_create_emisor =
        conn.prepare_cached("CALL create_emisor($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)")
            .unwrap();
    let mut imap_session = client
        .login(EMAIL, PASSWORD)
        .map_err(|e| e.0)
        .unwrap();
    imap_session.select("INBOX").unwrap();
    match imap_session.search("UNSEEN") {
        Ok(msgs_ids) => {
            for msg_id in &msgs_ids {
                let messages = imap_session.fetch(msg_id.to_string(), "BODY[]").unwrap();
                let message = if let Some(m) = messages.iter().next() {
                    m
                } else {
                    return ();
                };
                let body = message.body().expect("message did not have a body!");
                let parsed = mailparse::parse_mail(body).unwrap();
                for part in &parsed.subparts {
                    if part.ctype.mimetype == "text/xml" {
                        let body = part.get_body().unwrap();
                        println!("{:#?}",&body);
                        let package = parser::parse(&body)
                            .expect("<root>No XML</root>");
                        let document = package.as_document();
                        let factory = Factory::new();
                        let xpath = factory.build("//*[name()='FacturaElectronica']").expect("Could not compile XPath");
                        let xpath = xpath.expect("No XPath was compiled");
                        let context = Context::new();

                        let value = xpath.evaluate(&context, document.root())
                            .expect("XPath evaluation failed");
                        if (&value.string() != "") {
                            let new_now_factura = Instant::now();
                            let factura: FacturaElectronica = from_str(&body)
                                .unwrap();
                            stmt_create_factura.execute(&[
                                &factura.Clave,
                                &factura.CodigoActividad,
                                &factura.NumeroConsecutivo,
                                &(NaiveDateTime::parse_from_str(&factura.FechaEmision, "%+").unwrap()),
                                &factura.CondicionVenta,
                                &factura.MedioPago
                            ]).unwrap();
                            stmt_create_emisor.execute(&[
                                &factura.Emisor.Identificacion.Numero,
                                &factura.Emisor.Identificacion.Tipo,
                                &factura.Emisor.Nombre,
                                &(String::from(&factura.Emisor.NombreComercial)),
                                &factura.Emisor.Ubicacion.Provincia,
                                &factura.Emisor.Ubicacion.Canton,
                                &factura.Emisor.Ubicacion.Distrito,
                                &factura.Emisor.Ubicacion.OtrasSenas,
                                &factura.Emisor.Telefono.CodigoPais,
                                &factura.Emisor.Telefono.NumTelefono,
                                &factura.Emisor.CorreoElectronico,
                            ]).unwrap();
                            println!("{:#?}",htmlescape::decode_html(&factura.Emisor.NombreComercial));
                            println!("{:#?}", factura);
                            println!("{:?}", new_now_factura.duration_since(now));
                        } else {
                            let xpath = factory.build("//*[name()='MensajeHacienda']").expect("Could not compile XPath");
                            let xpath = xpath.expect("No XPath was compiled");
                            let context = Context::new();

                            let value = xpath.evaluate(&context, document.root())
                                .expect("XPath evaluation failed");
                            if (&value.string() != "") {
                                let mensajeHacienda: MensajeHacienda = from_str(&body)
                                    .unwrap();
                                println!("{:#?}", mensajeHacienda);new_now.duration_since(now)
                            } else {
                                println!("YIXXX");
                            }
                        }
                     }
                }
                println!("{:?}", parsed.subparts.len());
                let new_now = Instant::now();
                println!("{:?}", new_now.duration_since(now));
            }
        }
        Err(e) => println!("Error Fetching emails: {}", e),
    }
    imap_session.logout().unwrap();
}





























#[macro_use]
extern crate serde_derive;
extern crate chrono;
extern crate htmlescape;
extern crate serde;
extern crate serde_xml_rs as serde_xml;

extern crate imap;
extern crate mailparse;
extern crate native_tls;
extern crate sxd_document;
extern crate sxd_xpath;
extern crate tokio_postgres;

use chrono::format::ParseError;
use chrono::{DateTime, NaiveDate, NaiveDateTime, NaiveTime};
use serde_xml_rs::from_str;
use std::time::{Duration, Instant};
use sxd_document::parser;
use sxd_xpath::{Context, Factory, Value};
use tokio::process::Command;
use tokio::task;
use tokio::time;
use tokio_postgres::tls::MakeTlsConnect;
use tokio_postgres::{Client, Connection, Error, NoTls, Socket};

/*
#[tokio::main]
async fn main() -> Result<(), std::io::Error> {
    let list = imap_unseen::list().await;
    let imap_interval = task::spawn(imap_interval());
    imap_interval.await??;
    Ok(())
}

async fn imap_interval() -> Result<(), std::io::Error> {
    let mut interval = time::interval(Duration::from_secs(5));
    loop {
        imap_io().await;
        interval.tick().await;
        Command::new("date").spawn()?.await?;
    }
}

async fn imap_io() {
    let now = Instant::now();
    let tls = native_tls::TlsConnector::builder().build().unwrap();
    let imap_client = imap::connect((DOMAIN, 993), DOMAIN, &tls).unwrap();
    let mut imap_session = imap_client.login(EMAIL, PASSWORD).map_err(|e| e.0).unwrap();
    imap_session.select("INBOX").unwrap();
    match imap_session.search("UNSEEN") {
        Ok(msgs_ids) => {
            for msg_id in &msgs_ids {
                let messages = imap_session.fetch(msg_id.to_string(), "BODY[]").unwrap();
                let message = if let Some(m) = messages.iter().next() {
                    m
                } else {
                    return ();
                };
                let body = message.body().expect("message did not have a body!");
                // println!("{:#?}", &body); //[u8]
                let parsed = mailparse::parse_mail(body).unwrap();
                for part in &parsed.subparts {
                    if part.ctype.mimetype == "text/xml" {
                        let body = part.get_body().unwrap();
                        let package = parser::parse(&body).unwrap();
                        let document = package.as_document();
                        let factory = Factory::new();
                        let xpath = factory
                            .build("//*[name()='FacturaElectronica']")
                            .expect("Could not compile XPath");
                        let xpath = xpath.expect("No XPath was compiled");
                        let context = Context::new();
                        let value = xpath
                            .evaluate(&context, document.root())
                            .expect("XPath evaluation failed");
                        if (&value.string() != "") {
                            let new_now_factura = Instant::now();
                            let factura: structs::FacturaElectronica = from_str(&body).unwrap();
                            println!("{:#?}", &factura);
                        }
                    }
                }
            }
        }
        Err(e) => println!("Error Fetching emails: {}", e),
    }
    imap_session.logout().unwrap();
}
*/